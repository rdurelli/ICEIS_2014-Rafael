Software systems are considered legacy when their maintenance costs are raised to undesirable levels but they are still valuable for organizations. However, they can not be discarded because they incorporate a lot of embodied knowledge due to years of maintenance and this constitutes a significant corporate asset. As these systems still provide significant business value, they must then be modernized/re-engineered so that their maintenance costs can be manageable and they can keep on assisting in the regular daily activities. 

The first task that must be performed in order to carrying out a software modernization is understand the legacy system. It is not a trivial task, in fact studies estimate that between $50$ percent and $90$ percent of software maintenance involves developing an understanding of the software being maintained~\cite{Tilley95perspectiveson}, thus several approaches have been developed to support software engineers in the comprehension of systems where reverse engineering (RE) is one of them~\cite{Canfora2011}. RE supports program comprehension by using techniques that explore the source code to find relevant information related to functional and non-functional features~\cite{chikofskyTax}.

In this context, OMG (Object Management Group) has employed a lot of effort to define standards in the modernization process, creating the concept of ADM (Architecture-Driven Modernization). ADM follows the MDD (Model-Driven Development)~\cite{Ulrich:2010:IST:1841736}~\cite{5440163} guidelines and comprises two major steps. Firstly a reverse engineering is performed starting from the source code and a model instance (PSM) is created. Next successive refinements (transformations) are applied to this model up to reach a good abstraction level (PSM or CIM) in model called KDM (Knowledge Discovery Metamodel). Upon this model, several refactorings, optimizations and modifications can be performed in order to solve problems found in the legacy system. Secondly a forward engineering is carried out and the source code of the modernized target system is generated again. According to the OMG the most important artifact provided by ADM is the KDM metamodel, which is a multipurpose standard metamodel that represents all aspects of the existing IT (Information  Technology) architectures. The idea behind the standard KDM is that the community starts to create parsers from different languages to KDM. As a result everything that takes KDM as input can be considered platform and language-independent. For example, a refactoring catalogue for KDM can be used for refactoring systems implemented in different languages. 


Refactoring is another important research field well-known to enhance the quality of software. Martin Fowler~\cite{refactImpro} defines it as ``A change made to the internal structure of software to make it easier to understand and cheaper to modify without changing its observable behavior''. In the literature there is a lot of studies that make refactoring at the level of source code. Consequently, nowadays almost all Integrated Development Environmentd (IDE) provide some kind of automated support for program refactoring. Empirical studies of refactoring have shown that it can improve maintainability~\cite{1510132} and reusability~\cite{Moser:2006} of legacy system. Not only does existing work suggest that refactoring is useful, but it also suggests that refactoring is a frequent practice~\cite{Murphy:2011}. Cherubini and colleagues` survey indicates that developers rate the importance of refactoring as equal to or greater than that of understanding code and producing documentation~\cite{Cherubini:2007}.


In the area of object-oriented programming, refactorings are the technique of choice for improving the structure of legacy system without changing its external behavior [Opd92, Fow99, MT04]. Nowadays it is evident that refactorings are useful to improve the quality attributes of source code, and thus, to increase its maintainability. Unfortunately, although ADM had been created to support \hyphenation{mo-der-ni-za-tion} of legacy systems, to the best of our knowledge no catalogue of refactoings for the KDM specification exists. Available object-oriented refactoring catalogues can not be reusable as they are, because the KDM specification is based in MDD. This forces the software engineer to modernize a legacy system without any kind of dedicated support as using the KDM. As modernizing a legacy system can be very complex, manual modifications without any catalogue may lead to unwanted side-effects and result in a tedious and error-prove modernization process. Therefore, we argue that working out a catalogue of refactoring to the KDM specification is indispensable because by using it software engineers can reduce time and effort during the  modernization of legacy systems once we are using techniques of MDD~\cite{ThomasMDD, Ambler}. Furthermore, we also claim that devising a catalogue of refactoring by means of KDM specification makes this catalogue be both language-independent and standardized~\cite{Deltombe}~\cite{Castillo2012126}~\cite{Mainetti2012490}.     


%Although ADM/KDM had been created to support \hyphenation{mo-der-ni-za-tion} of legacy systems, to the best of our knowledge any catalogue of refactoring that uses the KDM specification as exist in object-oriented programming~\cite{refactImpro} is available in the literature.  We argue that this is indispensable because by using this catalogue software engineers can reduce time and effort during the  modernization of a legacy system once we are using MDD~\cite{ThomasMDD, Ambler}. Furthermore, we also argue that devising a catalogue of refactoring by means of KDM specification makes this catalogue be both language-independent and standardized~\cite{Deltombe}~\cite{Castillo2012126}~\cite{Mainetti2012490}.  

In this paper we present a dedicated catalogue of refactoring by means of KDM specification as exist in object-oriented programming. We claim that software engineers may perform refactorings over the KDM model without touching into the source-code. %In addition, creating a catalogue of refactoring based on KDM makes it language-independent and standardized. 
For outlining the catalogue of refactorings in the paper, we used a format inspired by Fowler~\cite{refactImpro}. More specifically we described the catalogue by \textit{(i)} giving a name to the refactoring, \textit{(ii)} describing the typical situation where the refactoring should be applied, \textit{(iii)} describing the solution to improve the problematic situation, \textit{(iv)} stating the preconditions that must be satisfied to be able to apply the refactoring, \textit{(v)} stating the parameters needed to provide the necessary information to execute the refactoring, \textit{(vi)} describing the refactoring steps and, for some of them, \textit{(vii)} discussing a concrete example application. 

Furthermore, we also have devised a proof-of-concept Modernization-Integrated Environment (MIE), which is a environment that implements all refactoring herein.  The novelty of this environment is not the supporting technologies and tools, but rather its catalogue of refactoring based on KDM.

To evaluate our catalogue of refactoring, we carried out an experiment through the refactoring of a legacy system in the academic domain. This legacy system is known as ProgradWeb, a system of the Federal University of S\~{a}o Carlos (UFSCar). ProgradWeb is a medium/large size academic system in operation since 1998, which stores all information about students, teachers, registration, certificates, diplomas and other issues related to undergraduate courses at UFSCar. The results achieved in the experiment shows that ProgradWeb was improved .

The remainder of this paper is organized as follows. Section~\ref{background} introduces the background of the paper: ADM, KDM and  . Section~\ref{Approach} shows the proposed \textit{Concern Identification} approach. Section~\ref{Evaluation} presents the evaluation of the approach. Section~\ref{Lesson} discusses our approach. Section~\ref{RW} briefly shows the related works. Finally, Section~\ref{Conclusions} discusses conclusions and future work.